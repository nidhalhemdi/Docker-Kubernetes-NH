# **Why would you use them?**

---

# üéØ **Purpose of Utility Containers**

Utility containers solve a key problem:

> **Some tools are required to *create* a project, even before you can containerize it.**
> Example: running `npm init` requires Node/NPM installed.

But Docker‚Äôs philosophy is:

* **Don‚Äôt install tools globally on your machine**
* **Use containers to provide environments**

The issue:
You cannot even start your project **unless** the tooling exists **somewhere**.

Utility containers fix this problem by letting you **run tools inside temporary containers**.

---

# üß© **Problem Illustration (Node Example)**

### To create a new Node project, you normally run:

```bash
npm init
```

This:

* asks questions
* generates `package.json`
* sets up defaults

### But‚Ä¶

* `npm` only exists if **NodeJS is installed**
* Installing Node locally breaks the Docker philosophy (‚Äúkeep host clean‚Äù)

You **could**:

* Copy/paste a template `package.json`
* Write it manually
  But this is tedious and not practical.

### This is **not only for Node**:

Other stacks need even more global tooling:

* PHP + Composer + Laravel installer
* Python project generators
* Go toolchains
* Java scaffolding tools

Utility containers help avoid installing all that.

---

# üß∞ **Utility Containers = Solution**

Instead of installing Node, PHP, Python, etc. locally:

### ‚≠ê Run the required tool **inside a container**:

Example:

```bash
docker run --rm node npm init
```

No Node installed ‚Üí still works!
Docker gives you the Node environment temporarily.

---

# ‚úî **Why Use Utility Containers?**

### **1. Keep your host machine clean**

* No global installs
* No version conflicts
* No polluting your OS

### **2. Run setup tools inside containers**

* npm
* composer
* laravel installer
* python venv tools
* go build tools

### **3. Create projects without installing tech stacks**

You can generate:

* Node apps
* PHP/Laravel apps
* React apps
* Vue apps
* Django apps

‚Ä¶all **without installing anything** locally.

### **4. Avoid complex environment setup**

For some languages (PHP/Laravel), local installation can be painful.
Utility containers simplify this.

---

# ‚öôÔ∏è **Important Technical Insight**

Utility containers rely on:

### üëâ **Running a container + command**

```bash
docker run <image> <command>
```

Which overrides the image‚Äôs default `CMD`.

This makes the container behave like a CLI tool.

---

# üìù **Practical Tips**

### **Tip 1 ‚Äî Always use `--rm`**

Automatically deletes the container after the command:

```bash
docker run --rm node npm init
```

### **Tip 2 ‚Äî Mount your project folder**

So the created files appear on your host:

```bash
docker run --rm -v $(pwd):/app -w /app node npm init
```

* `-v $(pwd):/app` ‚Üí mount current folder
* `-w /app` ‚Üí execute command inside that folder

You‚Äôll use this a lot later in Docker workflows.

### **Tip 3 ‚Äî Treat images like ‚Äútoolboxes‚Äù**

Just use the image that contains the tool you need.

Examples:

* Node image ‚Üí npm, npx
* PHP image ‚Üí composer
* Python image ‚Üí pip
* Golang image ‚Üí go build

---

# üß† **Core Concept to Remember**

> **Utility containers let you use development tools *inside Docker* so you don‚Äôt have to install them on your machine.**
