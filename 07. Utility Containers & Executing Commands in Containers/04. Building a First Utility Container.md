# **Building a First Utility Container**

---

# ğŸ¯ **Goal of This Lecture**

Build a **utility container**â€”a container used **not to run an application**, but to **run tools/commands** (like `npm init`) *without installing Node on your machine*.

And ensure that:

* Commands run **inside the container**
* Output (e.g., `package.json`) is created **on your host machine**
  using a **bind mount**

---

# ğŸ“Œ **Why Build a Utility Container?**

* Some languages need tools (npm, composer, artisan, etc.)
* You typically must install these tools globally on your machine
* Docker allows you to **use tools inside containers** instead
  â†’ host stays clean
  â†’ consistent environment
  â†’ very convenient for complex stacks (PHP, Laravel)

---

# ğŸ§± **1. Create the Dockerfile**

Example Dockerfile:

```dockerfile
FROM node:14-alpine

WORKDIR /app
```

Notes:

* `node:14-alpine` â†’ lightweight, fast, minimal
* `WORKDIR /app` â†’ all commands run in `/app`
* No `CMD` added â†’ image is flexible; user decides which command to run
  (e.g., `npm init`, `npm install`, etc.)

---

# ğŸ§± **2. Build the Utility Image**

```bash
docker build -t node-util .
```

This downloads the tiny Alpine Node image (~35 MB).

---

# ğŸ§ª **3. Run the Utility Container with `npm init`**

Run a command inside the image:

```bash
docker run -it node-util npm init
```

BUT this only affects the containerâ€™s internal filesystem.

So we add a **bind mount** to mirror the folder.

---

# ğŸ”— **4. Use a Bind Mount to Affect the Host Machine**

Example (Windows/Mac/Linux adapt path):

```bash
docker run -it -v "HOST_PATH":/app node-util npm init
```

Explanation:

* `-v host-folder:/app`
  â†’ your project folder on host is synced with containerâ€™s `/app`
* Running `npm init` **creates `package.json` on your host**, not inside some isolated container

Now you can answer the npm questions and see:

```
package.json
```

appear **on your host machine** instantly.

---

# ğŸ’¡ **Why This Is Powerful**

You can now:

* **Create Node projects without installing Node or NPM locally**
* Use **any tool** inside Docker as if installed locally
  (PHP, composer, artisan, Python, Java, Go, etc.)
* Keep your host machine clean
* Have consistent versions across projects

This is the true purpose of **utility containers**.

---

# ğŸ“ **Commands Summary**

### **Build the utility image**

```bash
docker build -t node-util .
```

### **Run npm init inside the container + mirror output**

```bash
docker run -it -v "YOUR/PATH/HERE":/app node-util npm init
```

---

# â­ **Key Takeaways**

* Utility containers = **containers dedicated to running commands/tools**
  (not running apps)
* Use **Alpine** images for small, fast utilities.
* Use **bind mounts** so actions inside the container affect your files.
* Use this pattern for all languages/frameworks that require local tools.