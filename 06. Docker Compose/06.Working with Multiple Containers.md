# **Working with Multiple Containers**

---

# ğŸ¯ Goal of This Lecture

Teach you how to fully configure the **backend service** in `docker-compose.yml`, including:

* **Building** the image (instead of providing a prebuilt one)
* Setting **ports**, **volumes**, **environment variables**, **bind mounts**, **anonymous volumes**
* Using **depends_on**
* How service names behave inside the container network

---

# ğŸŸ¦ 1. Adding the Backend Service

You uncomment or add:

```yaml
services:
  backend:
    ...
```

And now you configure it.

---

# ğŸŸ© 2. Building the Backend Image (instead of referencing an existing one)

### Short form (recommended):

```yaml
build: ./backend
```

This means:

* Look for a file named **Dockerfile**
* Use that to build the backend image
* Context = `./backend`

### Long form (used when):

* Dockerfile has a different name
* Dockerfile needs a special context

Example:

```yaml
build:
  context: ./backend
  dockerfile: Dockerfile-dev
  args:
    some-arg: some-value
```

**Context rule:**
The context folder must contain *everything your Dockerfile COPY commands refer to*.

---

# ğŸŸ¥ 3. Ports

Exactly like `docker run -p` but written in YAML:

```yaml
ports:
  - "80:80"
```

* Left = host
* Right = container
* Backend internally uses **port 80**

---

# ğŸŸ¨ 4. Volumes (3 types)

### âœ” Named volume

Needed for `app/logs`:

```yaml
volumes:
  - logs:/app/logs
```

AND define it at the bottom:

```yaml
volumes:
  logs:
```

---

### âœ” Bind mount

This is the development-friendly mount.

Instead of absolute paths, Compose allows **relative paths**:

```yaml
volumes:
  - ./backend:/app
```

This syncs the local backend folder with `/app` in the container.

---

### âœ” Anonymous volume

Same syntax as bind mount:

```yaml
volumes:
  - /app/node_modules
```

This prevents your host folder from overwriting container dependencies.

---

# ğŸŸ¦ 5. Environment variables via env file

You create:

```
env/backend.env
```

With content:

```
MONGODB_USERNAME=nidhal
MONGODB_PASSWORD=secret
```

And attach it:

```yaml
env_file:
  - ./env/backend.env
```

---

# ğŸŸ§ 6. depends_on

Used only in Docker Compose.

Why?
Because backend must start **after** MongoDB.

```yaml
depends_on:
  - mongodb
```

Compose will:

* Start *mongodb* first
* Then start backend

---

# ğŸŸª 7. Starting Everything

Run:

```
docker-compose up -d
```

Compose will:

* Build the backend image (because it doesn't exist)
* Pull the Node base image
* Start MongoDB
* Start the backend
* Create a network: `<project>_default`
* Create volumes: `<project>_data` etc.

---

# ğŸŸ« 8. Confirming Containers

```
docker ps
```

You might see names like:

* `docker-complete_backend_1`
* `docker-complete_mongodb_1`

Even though your service name is `backend` or `mongodb`.

**Important:**
â†’ Inside your code, you **must still use the service name**,
e.g.:

```js
mongoose.connect("mongodb://mongodb/some-db")
```

Because Docker Compose exposes service names as **internal DNS names**.

---

# â­ Key Takeaways

* Use **build** to create an image automatically.
* Ports, volumes, and env files translate cleanly into Compose format.
* Relative paths make bind mounts much easier.
* Service names are **hostnames** inside the Compose-created network.
* `depends_on` controls startup order.
* Generated container names do NOT change the service name used inside the network.

