# **Adding Another Container (Frontend)**

---

# ğŸ¯ Goal of This Lecture

Add the **React frontend container** to `docker-compose.yml` and configure:

* Building the frontend image
* Ports
* Bind mount for live reloading
* Interactive mode (`-it`) using Compose options
* Optional `depends_on`
* Running all three containers together

---

# ğŸŸ¦ 1. Adding the Frontend Service

You uncomment/add:

```yaml
services:
  frontend:
    ...
```

Then configure it similarly to the backend.

---

# ğŸŸ© 2. Build the Frontend Image

Since the frontend also uses its own Dockerfile:

```yaml
build: ./frontend
```

Docker Compose behavior:

* Only builds when **necessary** (code changed)
* Reuses existing images when possible
* Automatically detects when rebuild is required
  (very convenient for dev)

---

# ğŸŸ¥ 3. Ports

Expose the development server:

```yaml
ports:
  - "3000:3000"
```

React dev server runs inside the container on port **3000**.

---

# ğŸŸ¨ 4. Bind Mount for Live Development

This replaces the long absolute path used in `docker run`.

Using **relative path**:

```yaml
volumes:
  - ./frontend/src:/app/src
```

This ensures:

* When you edit React code locally
* Changes instantly update inside the running container

Perfect for development.

---

# ğŸŸ¦ 5. Interactive Mode (replacing `-it`)

React's dev server **needs** interactive mode (`-it`) or it wonâ€™t run correctly.

In Docker Compose the equivalent is:

```yaml
stdin_open: true
tty: true
```

Explanation:

* `stdin_open: true` â†’ equivalent to `-i` (keep STDIN open)
* `tty: true` â†’ equivalent to `-t` (allocate terminal)

Even in detached mode (`docker-compose up -d`), this ensures the React starter script works.

---

# ğŸŸ§ 6. Optional: depends_on

You may choose to delay frontend startup until backend starts:

```yaml
depends_on:
  - backend
```

Some frontends can start without backendâ€”but this is often convenient.

---

# ğŸŸª 7. Running Everything

Start all three services:

```
docker-compose up -d
```

Docker Compose will:

* Build the frontend image
* Notice backend doesnâ€™t need rebuilding
* Start mongodb â†’ backend â†’ frontend
  (according to dependencies)

Then you can access the application at:

```
http://localhost:3000
```

Everything works:

* Add goals
* Refresh
* Data persists â†’ because volumes store MongoDB data

ğŸ‘‰ After `docker-compose down`, volumes remain, so restarting is super fast.

---

# â­ Final Takeaways

* Compose makes multi-container setups **easy**, maintainable, and consistent
* Frontend needs `stdin_open` + `tty`
* Relative paths simplify bind mounts
* One file controls everything
* Only two main commands matter:

  * `docker-compose up`
  * `docker-compose down`

This is why Docker Compose is an essential tool for real projects.
