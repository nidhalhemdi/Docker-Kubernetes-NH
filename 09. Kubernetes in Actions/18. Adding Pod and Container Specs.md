# Adding Pod and Container Specs (Declarative Kubernetes Deployment)

After defining the high-level deployment fields (`apiVersion`, `kind`, `metadata`), this lecture expands the YAML file by adding the full **specification** for:

* the **Deployment**
* the **Pod template** inside that Deployment
* the **container** inside each Pod

This completes the ‚Äúminimum valid Deployment spec‚Äù ‚Äî except for the **selector**, which is introduced at the end.

---

# 1Ô∏è‚É£ Deployment `spec`

You add a `spec` field to describe **how the Deployment should behave**.

### ‚úî Setting number of replicas

```yaml
spec:
  replicas: 1
```

* Defaults to 1 if omitted.
* You can start with more (e.g., 3) if you expect traffic.
* Scaling later is optional because the declarative file lets you *start* with any number.

---

# 2Ô∏è‚É£ Adding the Pod Template (`template`)

Inside the Deployment `spec`, you add the **pod template** ‚Äî the blueprint of the pods the Deployment should create.

```
spec:
  replicas: 1
  template:
    ...
```

### Why this exists

A Deployment manages pods. The `template` block describes *what each pod should look like*.

---

# 3Ô∏è‚É£ Inside `template`: Pod Metadata and Labels

Each pod is **another Kubernetes object**, so its template needs metadata.

```yaml
template:
  metadata:
    labels:
      app: second-app
```

### ‚úî Why labels matter

* Pods need labels so the Deployment can **select** them.
* Without labels, the Deployment cannot match pods to itself.
* This becomes critical later when creating **selectors**.

Labels are arbitrary key‚Äìvalue pairs ‚Äî you can choose any keys and values.

---

# 4Ô∏è‚É£ Pod Specification (`spec` for the pod)

Next, you define what the pod *contains*:

```yaml
template:
  ...
  spec:
    containers:
      - name: second-node
        image: <your_registry>/kub-first-app:latest
```

### ‚úî Key points

* `containers:` must be a list (`-`).
* You can define multiple containers inside one pod, but here we only need one.
* The container has:

  * A **name** (arbitrary)
  * An **image** (same as you would pass using `--image` in the imperative approach)

### ‚úî Container image

The image must be available in a registry:

```
<dockerhub-username>/kub-first-app:latest
```

Same image used earlier for imperative deployment.

---

# 5Ô∏è‚É£ Applying the YAML With `kubectl apply`

Instead of `kubectl create`, you now use:

```
kubectl apply -f=deployment.yaml
```

This tells Kubernetes:

> "Make the cluster match the state described in this file."

You can apply any time ‚Äî Kubernetes updates existing deployments automatically.

---

# 6Ô∏è‚É£ ‚ùóThe Missing Piece: `selector`

When applying the file, you get:

```
error: missing required field "selector"
```

This is intentional and important.

### ‚úî Why does Kubernetes need a selector?

A Deployment must define:

* Which pods **belong to it**
* Which pods it should manage, scale, update, or delete

Kubernetes relies on **labels** + **selectors** to link Deployments to Pods.

Since you added labels like:

```
app: second-app
```

‚Ä¶your Deployment must now specify a **matching selector**.

Without it, Kubernetes cannot know which pods it should control.

This sets up the next lecture.

---

# üéâ What You Now Understand

You‚Äôve learned all the inner components required to build a Deployment:

* Deployment-level configuration (`spec`)
* Number of pod replicas
* Pod template
* Pod metadata (labels)
* Pod specification (container definition)
* How to apply the file

The only missing part is the **selector**, which binds labels ‚Üí pods ‚Üí deployment.
