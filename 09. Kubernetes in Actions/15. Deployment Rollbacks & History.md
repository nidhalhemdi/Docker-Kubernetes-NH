# **Deployment Rollbacks & History**

This lecture shows how Kubernetes handles failed updates and how you can **roll back** to previous deployment versions using Kubernetes' built-in rollout system.

---

# 1Ô∏è‚É£ When an Update Fails

If you update a deployment with a **non-existent image tag**, for example:

```
kubectl set image deployment/first-app kub-first-app=nidhalhaamdii/kub-first-app:nope
```

Kubernetes will **attempt** to perform a rolling update but fail.

### How to check what's happening:

```
kubectl rollout status deployment/first-app
```

Important notes:

* This command runs in a **blocking/interactive** mode (continuously watching the deployment).
* Cancel it using **Ctrl + C**.
* You‚Äôll see messages like:

  * Waiting for rollout to finish
  * Old replica set not scaled down
  * New pod failing to start

---

# 2Ô∏è‚É£ What You See in the Dashboard When Update Fails

* The **old pod is not terminated** (Kubernetes protects you!)
* A **new pod is created**, but:

  * It fails to pull the image
  * It gets stuck in `ImagePullBackOff`
  * The whole rollout is stuck

This is part of Kubernetes' **safe rolling update strategy**:
‚úî Never drop the old working Pods
‚úî Only switch once the new Pods are healthy

---

# 3Ô∏è‚É£ Rolling Back a Failed Deployment

You can undo the most recent change with:

```
kubectl rollout undo deployment/first-app
```

Results:

* The broken Pod disappears
* Kubernetes goes back to the previous working ReplicaSet
* Application becomes healthy again

---

# 4Ô∏è‚É£ Viewing Deployment History

List deployment history:

```
kubectl rollout history deployment/first-app
```

You will see a list of **revisions** (versioned states of your deployment).

View details for a specific revision:

```
kubectl rollout history deployment/first-app --revision=3
```

Useful to inspect:

* Which image was used
* What changed
* Why that revision may be broken

---

# 5Ô∏è‚É£ Rolling Back to a Specific Revision

You can revert to *any* previous revision, not just the last one:

```
kubectl rollout undo deployment/first-app --to-revision=1
```

After this rollback:

* Kubernetes switches back to the Pod template from that revision
* The Pods are recreated using the older image (e.g., original version)
* Your app output reflects the older version

---

# 6Ô∏è‚É£ Why Deployment Rollbacks Matter

Kubernetes automatically handles:

‚úî ReplicaSet tracking
‚úî Pod replacement
‚úî Safe rollouts
‚úî Safe rollbacks

This is essential in production environments where:

* Failed updates must be reversible
* App downtime must be avoided
* Deployments must be consistent and traceable

---

# 7Ô∏è‚É£ Cleanup Before Moving to Declarative Approach

Before continuing, the lecture deletes the existing objects:

```
kubectl delete service first-app
kubectl delete deployment first-app
```

This resets the environment for upcoming declarative YAML configuration examples.

---

# üìå Key Takeaways

* Kubernetes keeps a **history** of deployment revisions.
* Failed rollouts don't break your app thanks to the rolling update strategy.
* You can:

  * Undo the last rollout
  * View rollout history
  * Roll back to any previous revision
* These features make Kubernetes extremely reliable for real-world production deployments.
