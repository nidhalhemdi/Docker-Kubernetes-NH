# **Summary : Kubernetes in Action: Core Concepts**

This module was a major milestone in learning Kubernetes. You now understand both the **architecture** and the **practical workflow** needed to work with Kubernetes clusters.

---

# ğŸ”§ **1. Setting Up the Kubernetes Environment**

You learned:

* What a Kubernetes cluster consists of (control plane + worker nodes)
* That tools can help set up clusters:

  * **Minikube** â†’ for local development
  * Cloud providers â†’ offer their own tools (covered later)
* You installed **kubectl**, the main command-line tool to communicate with Kubernetes clusters.

---

# ğŸ“¦ **2. Kubernetes Objects (Resources)**

Everything deployed in Kubernetes is an **object**, such as:

* Deployments
* Pods
* Services
* ConfigMaps
* â€¦and more

These objects define your desired application state.

---

# âš™ï¸ **3. Two Ways to Work With Kubernetes: Imperative vs Declarative**

### **Imperative approach**

You directly tell Kubernetes *what to do* with commands:

Examples:

```
kubectl create deployment ...
kubectl expose deployment ...
kubectl delete deployment ...
kubectl set image ...
```

Pros: quick and easy for experimentation
Cons: not scalable, not maintainable

---

### **Declarative approach**

You define the desired state in YAML files and apply them:

```
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
```

Pros:

* version-controlled configuration
* scalable
* easy updates: only changed parts get applied
* repeatable & predictable

You can apply:

* one file
* multiple files
* or a combined file with multiple resource definitions separated by `---`.

You can also delete resources created from files:

```
kubectl delete -f deployment.yaml
```

---

# ğŸ·ï¸ **4. Labels, Selectors, and Connecting Resources**

You learned:

* **Labels** â†’ metadata that identify resources
* **Selectors** â†’ used to connect resources (e.g., services â†’ pods, deployments â†’ pods)

Selectors match **labels**, never names.

This ensures Kubernetes knows which Pods belong to which Deployment or Service.

---

# ğŸ¥ **5. Health Checks (Liveness Probes)**

You defined a custom **liveness probe** using:

```yaml
livenessProbe:
  httpGet:
    path: /
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 3
```

This lets Kubernetes automatically restart unhealthy containers.

---

# ğŸ”„ **6. Image Pull Policies**

You learned how Kubernetes decides whether to pull new images:

* If tag = `latest`, Kubernetes should pull automatically.
* With custom tags (e.g., `:2`), Kubernetes **wonâ€™t** repull unless:

```yaml
imagePullPolicy: Always
```

was set.

This ensures Kubernetes always fetches the latest image version.

---

# ğŸ“˜ **7. Kubernetes API Reference**

You explored the official Kubernetes documentation to understand:

* All available configuration fields
* Container options (env vars, commands, image pull policies, etc.)
* Pod-level options

You learned that:

* Many options exist
* Most are rarely needed
* Donâ€™t be overwhelmedâ€”use docs when necessary

---

# ğŸ¯ **8. Skills Acquired in This Module**

At this point, you understand:

âœ” What Kubernetes *is* and what problem it solves
âœ” How to set up a local cluster
âœ” How to create, update, and delete resources
âœ” How to use both imperative and declarative workflows
âœ” How pods, containers, labels, selectors, and services work together
âœ” How to control container health and image pulling
âœ” The big-picture architecture *and* hands-on execution

This gives you a solid foundation for real-world Kubernetes development.

---

# ğŸš€ **Next Steps**

In the upcoming modules, you will dive deeper into real-world Kubernetes features:

* Volumes (persistent storage)
* ConfigMaps & Secrets
* Scaling
* Ingress controllers
* Cloud deployments
* More advanced Kubernetes patterns and architecture
