# **Liveness Probes in Kubernetes**

Kubernetes needs a way to determine whether your **pods** and their **containers** are healthy. By default, it uses basic internal signals, but for real applications you often need to **explicitly configure health checks**. This is where **liveness probes** come in.

---

## ğŸ©º **What is a Liveness Probe?**

A **liveness probe** tells Kubernetes *how to check whether a container is alive*.
If the probe fails, Kubernetes automatically **restarts the container**.

You configure liveness probes inside the **container** section of a Deploymentâ€™s Pod template.

---

## âš™ï¸ **How to Add a Liveness Probe**

Inside `spec.template.spec.containers[]`, you add:

```yaml
livenessProbe:
  httpGet:
    path: /
    port: 8080
  periodSeconds: 3
  initialDelaySeconds: 5
```

### Meaning of these fields:

* **httpGet:** Kubernetes will send an HTTP GET request

  * `path`: the endpoint to check (e.g., `/`, `/health`, `/status`)
  * `port`: port exposed by the container
* **periodSeconds:** how often Kubernetes should check
* **initialDelaySeconds:** how long to wait before the first check (gives the app time to start)

Kubernetes supports other probe types too:

* `tcpSocket`
* `exec` (run a command inside the container)

---

## ğŸ” **What Happens When a Liveness Probe Fails?**

If the HTTP endpoint returns an error (e.g., 500 or server crash), Kubernetes considers the container *unhealthy*.
It will:

1. Kill the container
2. Restart it automatically

This keeps your applications self-healing.

---

## ğŸ§ª **Demonstration**

After configuring the probe:

* Apply your updated deployment:

  ```
  kubectl apply -f deployment.yaml
  kubectl apply -f service.yaml
  ```
* Access the service using:

  ```
  minikube service backend
  ```

If you visit a crashing route (e.g., `/error`), the pod will crash, and Kubernetes will **immediately restart it**, which you can verify using:

```
kubectl get pods
```

Youâ€™ll see the `RESTARTS` count increment.

---

## ğŸ“ **Why Liveness Probes Matter**

They ensure that Kubernetes can:

* Detect application crashes
* Recover from unresponsive endpoints
* Keep your application continuously running
* Customize health checks based on how *your* app works (not just defaults)

These are especially important for applications that:

* Freeze without fully exiting
* Have long startup times
* Require custom health endpoints
