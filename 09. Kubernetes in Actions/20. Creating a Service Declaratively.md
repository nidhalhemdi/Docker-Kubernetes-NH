# Creating a Service Declaratively (Kubernetes)

Having only a Deployment is not enough—you also need a **Service** to expose your Pods. This lecture explains how to create such a Service **declaratively**, using a `service.yaml` file.

---

# 1️⃣ Create a New File: `service.yaml`

Just like the Deployment uses `deployment.yaml`, a Service is defined in its own config file.

A Kubernetes YAML file always needs:

1. `apiVersion`
2. `kind`
3. `metadata`
4. `spec`

---

# 2️⃣ API Version for Services

For Deployments we used:

```yaml
apiVersion: apps/v1
```

But for Services, the API group is **core**, so you simply use:

```yaml
apiVersion: v1
```

---

# 3️⃣ Service Kind + Metadata

```yaml
kind: Service
metadata:
  name: backend   # You choose the name
```

The file name (`service.yaml`) does NOT determine what gets created—only the **kind** field does.

---

# 4️⃣ Service Spec: Define How the Service Works

This is where the key configuration goes.

## ✔ Add a selector (different from Deployment selectors)

The Service must know **which pods** it should expose.

* Deployment selectors use `matchLabels:`
* Service selectors use **direct key/value pairs** because Services are older API objects.

Example:

```yaml
spec:
  selector:
    app: second-app
```

You can select as many labels as you want, but usually **one is enough**.

---

# 5️⃣ Define Ports

A Service can expose one or multiple ports.
That's why `ports:` is a list:

```yaml
ports:
  - protocol: TCP
    port: 80        # Port exposed by the service (external)
    targetPort: 8080  # Port inside the container
```

Meaning:

* Users access the service through **port 80**
* The traffic goes to the containers on **port 8080**

(These numbers match your application’s configuration.)

---

# 6️⃣ Specify the Service Type

Service type decides **how** the service is exposed:

| Type           | Description                                            |
| -------------- | ------------------------------------------------------ |
| `ClusterIP`    | Default; accessible only inside the cluster            |
| `NodePort`     | Exposes the service on the node’s IP and a high port   |
| `LoadBalancer` | Exposes it publicly; uses cloud provider load balancer |

For Minikube (or real cloud):

```yaml
type: LoadBalancer
```

This gives you a real, externally reachable URL.

---

# 7️⃣ Full Service YAML

```yaml
apiVersion: v1
kind: Service
metadata:
  name: backend
spec:
  selector:
    app: second-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: LoadBalancer
```

---

# 8️⃣ Create the Service

Run:

```
kubectl apply -f service.yaml
```

Then:

```
kubectl get services
```

You will see the new Service listed.

To open it in your browser (Minikube):

```
minikube service backend
```

This opens the app in a new browser tab using the load balancer URL.

---

# 9️⃣ Why Declarative is Better

* No need to remember long commands
* Easy to edit, maintain, and share
* Configuration is visible to teammates
* Less error-prone
* This is the standard approach in real Kubernetes projects
