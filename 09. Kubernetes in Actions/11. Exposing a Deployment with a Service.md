# **Exposing a Deployment with a Service**

To make a Pod reachable **outside the Kubernetes cluster**, you must create a **Service**.

In this lecture, we will see how to expose a Deployment using the **imperative command**:

```
kubectl expose
```

---

# 1Ô∏è‚É£ Why `kubectl expose`?

Instead of manually creating a Service with:

```
kubectl create service ...
```

‚Ä¶it‚Äôs easier to expose an existing Deployment with:

```
kubectl expose deployment <deployment-name>
```

This automatically creates the correct Service and links it to the Pods managed by that Deployment.

---

# 2Ô∏è‚É£ Required Flags

### ‚úî **`--port=`**

The port your container **listens on** (inside the Pod).
Your Node.js app runs on **8080**, so:

```
--port=8080
```

---

### ‚úî **`--type=`**

Defines how the Service is exposed.

#### Three common types:

| Type                    | Meaning                                  | External Access?            |
| ----------------------- | ---------------------------------------- | --------------------------- |
| **ClusterIP (default)** | Only reachable inside the cluster        | ‚ùå No                        |
| **NodePort**            | Opens a port on each Worker Node         | ‚úî Yes                       |
| **LoadBalancer**        | Creates LoadBalancer in your cloud infra | ‚úî Yes (best for production) |

**Minikube supports LoadBalancer**, but it will **not** show an external IP (shows `pending`).

So for Minikube, you still use `LoadBalancer`, but fetch the IP using a Minikube command.

---

# 3Ô∏è‚É£ Command to Expose the Deployment

### üëâ **Create a LoadBalancer-type Service**

```
kubectl expose deployment first-app --port=8080 --type=LoadBalancer
```

This creates a Service linked to all Pods created by the Deployment.

---

# 4Ô∏è‚É£ Check the Created Service

```
kubectl get services
```

You will see:

* a default `kubernetes` service
* your `first-app` service
* its **Cluster IP**
* its **type (LoadBalancer)**
* **External IP = pending** (always in Minikube)

Cloud providers (AWS, GCP, Azure) would show a real external IP.

---

# 5Ô∏è‚É£ Accessing the App in Minikube

Because Minikube runs inside a virtual machine, it cannot allocate a real public IP.
So Minikube provides a helper command:

### üëâ **Get service URL**

```
minikube service first-app
```

This outputs a table with a URL like:

```
http://127.0.0.1:50723
```

Minikube will also automatically open the browser.

This URL routes to:

‚Üí the Service
‚Üí which forwards to the Pod(s)
‚Üí which runs the containerized Node app.

---

# 6Ô∏è‚É£ What You Achieved

You now have:

* A **Deployment** managing Pods
* A **Service** exposing the Pods
* A reachable web application running inside Kubernetes
* All created via the **imperative approach**

These three objects (Pod ‚Üí Deployment ‚Üí Service) are the core of almost every Kubernetes application.

---

# üìå **Important Commands List**

### **Expose Deployment**

```
kubectl expose deployment first-app --port=8080 --type=LoadBalancer
```

### **List services**

```
kubectl get services
```

### **Open service URL in Minikube**

```
minikube service first-app
```
