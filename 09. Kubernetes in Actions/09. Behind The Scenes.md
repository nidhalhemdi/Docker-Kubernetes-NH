# **kubectl: Behind the Scenes**

When you run:

```bash
kubectl create deployment first-app --image=your-image
```

a LOT happens behind the scenes. Understanding this is key to really â€œgettingâ€ Kubernetes.

---

# 1ï¸âƒ£ **kubectl â†’ Master Node (Control Plane)**

`kubectl` is a CLI tool that *always runs on your local machine*.
It sends commands to the **Master Node** (also called the *Control Plane*) of the Kubernetes cluster.

It does **NOT** run the containers itself.
It only sends **instructions** like:

* â€œCreate a Deploymentâ€
* â€œScale to 3 replicasâ€
* â€œDelete this Podâ€
* etc.

Minikube automatically configures `kubectl` to talk to your Minikube cluster, so you donâ€™t need extra configuration.

---

# 2ï¸âƒ£ **Master Node Processes the Request**

When the Master Node receives the deployment object, several internal components get involved:

### âœ” **API Server**

Receives the deployment manifest and stores it.

### âœ” **Controller Manager**

Sees:

> â€œA Deployment wants 1 Podâ€

If the Pod does not exist, the controller creates it.

### âœ” **Scheduler**

The Scheduler decides *where* the Pod should run.

It picks a worker node based on:

* Available CPU
* Available RAM
* Existing workload
* Node conditions

Example:

> â€œThe bottom Worker Node has the most free resources, so I'll schedule the Pod there.â€

---

# 3ï¸âƒ£ **Worker Node Takes Over**

Once the Pod is assigned to a worker:

### âœ” **kubelet**

Each Worker Node runs a service called **kubelet**.

It is responsible for:

* Pulling the container image
* Creating and starting the container
* Monitoring its health
* Reporting back to the Master Node

So `kubelet` receives instructions like:

> â€œPlease run this Pod using this container image.â€

Then it actually executes the container runtime to start the container.

---

# 4ï¸âƒ£ **Image Pulling**

The Worker Node must pull the image from wherever it lives:

* Docker Hub
* Google Container Registry
* Private registry

If you used a **local image**, the Worker Node cannot see it â†’ *ImagePullError*.

This is exactly why you needed to push the image to Docker Hub.

---

# 5ï¸âƒ£ **Result: The Pod Is Now Running**

You can verify it with:

```bash
kubectl get deployments
kubectl get pods
```

Once the Pod is created and the container is running, Kubernetes continuously checks:

* Is the Pod healthy?
* Is the container alive?
* Does it need to be restarted?
* Does the Deploymentâ€™s desired state match the actual state?

Kubernetes always tries to ensure that real state = desired state.

---

# ğŸ¤ Final Idea: Kubernetes Is a â€œDesired State Machineâ€

You tell Kubernetes what you **want**.

Kubernetes figures out **how to get there**.

kubectl â†’ Deployment â†’ Pod â†’ Scheduler â†’ Worker Node â†’ kubelet â†’ Container
All of this happens automatically behind the scenes.

