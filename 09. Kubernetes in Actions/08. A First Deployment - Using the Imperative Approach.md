# **Creating Your First Deployment Imperatively**

This lecture walks you through your **first real Kubernetes deployment**, using the **imperative approach** (`kubectl create â€¦`).
It also explains the workflow of building Docker images, pushing them to a registry, and using them in your Kubernetes cluster (Minikube).

---

# ðŸŸ¦ 1. You STILL Need Docker Images

Even though Kubernetes manages containers for you:

ðŸ‘‰ **You must still build a Docker image** for your application.
Kubernetes cannot run your app without a container image.

The example app:

* Simple Node.js server
* Two endpoints: `/nothing` and `/error` (the second intentionally crashes)
* Dockerfile included (basic Node.js Dockerfile)

---

# ðŸŸ¦ 2. Build Your Image Locally

You build the Docker image the same way you always do:

```sh
docker build -t kub-first-app .
```

Nothing new â€” this step is 100% Docker, not Kubernetes.

---

# ðŸŸ¦ 3. Ensure Minikube Is Running

You must verify the Kubernetes cluster is active:

```sh
minikube status
```

If not running:

```sh
minikube start --driver=docker
```

(Or VirtualBox / Hyper-V depending on OS.)

Minikube simulates a cluster using a Virtual Machine.

---

# ðŸŸ¦ 4. Create a Deployment (Imperative Approach)

Run:

```sh
kubectl create deployment first-app --image=kub-first-app
```

BUTâ€¦

ðŸš¨ **This fails** â€” even though the command says "created" â€” because:

* The Kubernetes node is inside the Minikube VM.
* That VM **does NOT have access to your local Docker images**.
* Kubernetes tries to **pull** the image from a registry.
* Since itâ€™s not on Docker Hub â†’ **ImagePullError**.

Check the issue with:

```sh
kubectl get deployments
kubectl get pods
```

You'll see **0/1 ready**, status: `ImagePullBackOff` or `ImagePullError`.

---

# ðŸŸ¦ 5. Fix: Push Your Image to a Registry (Docker Hub)

Steps:

1. Create a repo on Docker Hub (e.g., `kub-first-app`).
2. Tag your local image:

```sh
docker tag kub-first-app YOUR-DOCKERHUB-USER/kub-first-app
```

3. Push it:

```sh
docker push YOUR-DOCKERHUB-USER/kub-first-app
```

Now the image exists in a place Kubernetes can pull it from.

---

# ðŸŸ¦ 6. Recreate Deployment Using the Remote Image

Delete the broken deployment:

```sh
kubectl delete deployment first-app
```

Create again with the Docker Hub image:

```sh
kubectl create deployment first-app --image=YOUR-DOCKERHUB-USER/kub-first-app
```

Check status:

```sh
kubectl get deployments
kubectl get pods
```

âœ” Now you should see:

* `1/1 READY`
* Pod status = `Running`

This means your application is successfully deployed!

---

# ðŸŸ¦ 7. Explore Using Minikube Dashboard

Open the cluster dashboard:

```sh
minikube dashboard
```

You can visually inspect:

* Deployments
* Pods
* Labels
* Pod internal IP
* Pod health/status

This confirms the deployment is truly running.

âš  **Important:** The Pod IP is internal to the cluster; you cannot access it directly from your browser.

Later explain how to expose it using Kubernetes Services.

---

# ðŸŸ¦ 8. What Actually Happened Behind the Scenes

When you ran:

```sh
kubectl create deployment â€¦
```

Kubernetes:

1. Created a **Deployment object**
2. Deployment created a **ReplicaSet**
3. ReplicaSet created **1 Pod**
4. Pod pulled your image from Docker Hub
5. Pod started your Node.js container
6. Kubernetes placed the Pod on Minikubeâ€™s virtual node

You now have your first fully managed Kubernetes workload.

---

# ðŸŽ‰ **Key Takeaways**

* You must push images to a registry (local images won't work in Minikube).
* `kubectl create deployment` uses the **imperative** (command-driven) approach.
* `kubectl get deployments/pods` helps debug pod status.
* Minikube dashboard is excellent for understanding what Kubernetes is doing.
* Your app is running but not yet reachable â€” Services come next.
