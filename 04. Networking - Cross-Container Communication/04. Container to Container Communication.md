# **Case 3 — Container → Container Communication**

### **Core Concept**

A very common situation in Docker is when **one container needs to talk to another container**.

Example:

* Container A → Node.js app
* Container B → MySQL / MongoDB / another service

Your application inside Container A may need to:

* Send requests
* Store/read data
* Communicate via a network protocol
  …with Container B.

This is **cross-container communication**.

---

### **Why This Happens**

Modern apps are built as **multi-container architectures**:

* **Best Practice:**
  **One container = one responsibility**

  Example:

  * Node.js app → 1 container
  * MongoDB database → 1 container
  * Redis cache → 1 container
  * NGINX reverse proxy → 1 container

Containers should be small, focused, and modular.

---

### **Key Points**

* Container → container communication is **very common**.
* We’ve used only single-container apps so far, but real apps require more.
* The upcoming demo project will use **multiple containers**:

  * A Node.js app container
  * A MongoDB container
* The Node container must be able to talk to the DB container.

This introduces:

* Docker networks
* How containers discover each other
* How they communicate internally without exposing everything to the host

---

### **Simple Definitions**

* **Multi-container app**: Application composed of multiple specialized containers.
* **Cross-container communication**: Containers connecting to each other for data or services.
* **Service separation**: Each service (app, database, worker) runs in its own container.

---

### **Why It Matters**

Most real-world Docker setups involve:

* App container ↔ DB container
* Frontend container ↔ backend container
* Backend container ↔ cache container

So understanding container-to-container networking is essential.