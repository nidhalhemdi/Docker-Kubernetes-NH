# **Case 2 — Container → Local Host Machine Communication**

### **Core Concept**

Beyond talking to the internet, a container may need to communicate with **services running directly on your host machine**.

Examples on your host:

* Local **database** (e.g., MongoDB)
* Local **API** or backend server
* Any software **not running in Docker**

This is a different kind of communication:

* Still *container → outside world*
* But **not** container → website
* Instead: **container → host machine**

---

### **Scenario Used**

In the demo Node.js application:

* The app **fetches data from Star Wars API** (Case 1).
* But it also needs to **store and retrieve data** in MongoDB.
* This MongoDB is **running on the host machine**, *NOT* in Docker.

So the containerized Node.js app must be able to:
➡️ Connect to MongoDB running locally on the computer.

### **Why This Matters**

This is a very common real-world setup:

* You are experimenting with Docker.
* But your database or another service is still running directly on your OS.

Your container must be configured correctly to talk to:

* `localhost` of the **host machine**, which is not the same as `localhost` **inside** the container.

(How to achieve this will be explained later in the module.)

---

### **Important Definitions**

* **Host machine**: The actual computer that is running Docker.
* **Container → host communication**: App inside container reaches a service running outside Docker.
* **Local database**: A database installed directly on your OS (MongoDB, MySQL, PostgreSQL, etc.).

---

### **Key Takeaways**

* Containers often need to access services on the host.
* Outbound communication is not always “to the internet”.
* Docker handles this differently than container → web communication.
* The demo app will show how to connect a Dockerized Node app to a **host-running MongoDB**.