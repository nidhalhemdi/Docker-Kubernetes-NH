# **Container-to-Container Communication â€” A Basic Solution**

- Introducing **cross-container communication**, where one container (Node.js API) connects to another container (MongoDB).

---

# ğŸ¯ **Goal**

Run:

* **1 container** for the Node.js API
* **1 container** for MongoDB
  And make them communicate **inside Docker**, without using the host machine.

---

# ğŸ§± **Step 1 â€“ Stop the existing Node.js container**

```bash
docker stop favorites
```

---

# ğŸ§± **Step 2 â€“ Run MongoDB in its own container**

We **do NOT** need a Dockerfile for MongoDB.

### Use the official MongoDB image:

```bash
docker run -d --name mongodb mongo
```

* `mongo` is the official image on Docker Hub.
* This starts a fully working MongoDB server inside a container.

---

# ğŸ§± **Step 3 â€“ Find MongoDB container's internal IP**

Because `host.docker.internal` **only points to the host**, not to other containers.

### Get MongoDB container details:

```bash
docker container inspect mongodb
```

Look for:

```
NetworkSettings -> IPAddress
```

Example:

```
"IPAddress": "172.17.0.2"
```

Each personâ€™s IP will differ.

---

# ğŸ§± **Step 4 â€“ Update Node.js connection string**

Replace the old host-based connection:

```js
mongoose.connect('mongodb://host.docker.internal:27017/some-db');
```

with the **container's internal IP**:

```js
mongoose.connect('mongodb://172.17.0.2:27017/some-db');
```

This allows Node.js container â†’ MongoDB container communication.

âš ï¸ **This is functional but not ideal**
(Youâ€™ll see a better solution in the next lecture.)

---

# ğŸ§± **Step 5 â€“ Rebuild Node Image**

Because the source code (connection string) changed:

```bash
docker build -t favorites-node .
```

---

# ğŸ§± **Step 6 â€“ Run the Node container**

```bash
docker run -d --rm --name favorites -p 3000:3000 favorites-node
```

---

# ğŸ§± **Step 7 â€“ Test communication**

Sending a request:

```
GET http://localhost:3000/favorites
```

Result:

* Returns: `[]` (empty array)
* Why?
  Because this is a **fresh MongoDB instance** inside the containerâ€”not your old local database.

Add an item â†’ GET again â†’ the new data appears.

This confirms:
âœ” Both containers communicate successfully
âœ” No errors from MongoDB connection

---

# âš ï¸ **But the method is inconvenient**

Problems with using container IPs:

1. You must **inspect** the container each time to find its IP.
2. The IP **may change** if the container restarts.
3. The IP is **hard-coded** in the Node.js application, which means:

   * Rebuilding the image every time
   * Not portable
   * Not scalable

This is why Docker provides a **better, simpler mechanism**, which is introduced next: **Docker networks with container name resolution**.
