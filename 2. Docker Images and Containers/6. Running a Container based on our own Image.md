# Building & Running Your Own Image

## Dockerfile (example)

Save this file named **`Dockerfile`** in the project folder (same folder as `server.js` and `package.json`):

```Dockerfile
# start from official Node base image
FROM node

# set working directory inside the image
WORKDIR /app

# copy project files into the image
COPY . /app

# install dependencies (runs during image build)
RUN npm install

# document which port the app listens on (best practice only)
EXPOSE 80

# command that runs when a container is started from this image
CMD ["node", "server.js"]
```

**Tip:** Add a `.dockerignore` file to avoid copying unnecessary files (e.g., `node_modules`, `.git`, `*.log`) — speeds up builds and keeps images smaller.

---

## Build the image

Run this where the Dockerfile is (the `.` means current folder):

```bash
docker build -t my-node-app .
```

* `-t my-node-app` tags the image with a readable name (`my-node-app`).
* When build finishes you’ll get an image ID and the tagged image will appear in `docker images`.

---

## Run a container from the image

Important: `EXPOSE` in the Dockerfile is documentation only — it does **not** publish the port to your host. Use `-p` when running.

```bash
# publish host port 3000 to container port 80 and run in foreground
docker run -p 3000:80 my-node-app

# or run detached (background) and give it a name
docker run -d -p 3000:80 --name my-node-container my-node-app
```

* Syntax `-p <hostPort>:<containerPort>` — maps host port to container port.
* Use `-d` to detach (run in background). Use `--name` to assign a friendly container name.

Now open: `http://localhost:3000` → your app.

---

## Inspecting & stopping containers

```bash
# show running containers
docker ps

# show all containers (running + stopped)
docker ps -a

# stop a running container
docker stop my-node-container   # or use the container ID

# remove a stopped container
docker rm my-node-container
```

If you started in foreground (no `-d`), use `Ctrl+C` to stop (or do `docker ps` in another terminal → `docker stop <id>`).

---

## Logs & troubleshooting

```bash
# view container logs
docker logs my-node-container

# follow logs in real time
docker logs -f my-node-container
```

If your app doesn't respond:

* Confirm `docker ps` shows container running.
* Confirm you used `-p host:container` when running.
* Confirm app listens on the container port (80 in this example).

---

## Useful image & container cleanup

```bash
# list images
docker images

# remove an image by name or ID (image must not be used by a container)
docker rmi my-node-app

# remove all stopped containers
docker container prune

# remove dangling images
docker image prune
```

---

## Extra practical tips & gotchas

* **Do not run `node server.js` inside the Dockerfile** — use `CMD` so the command runs in the **container** (not during image build).
* **WORKDIR** sets the directory for subsequent instructions (`COPY`, `RUN`, etc.). Using `WORKDIR /app` is convenient and recommended.
* Use absolute paths in `COPY` if you prefer explicitness: `COPY . /app`.
* Include a **`.dockerignore`** to skip `node_modules`, `.git`, etc. Example `.dockerignore`:

  ```
  node_modules
  .git
  npm-debug.log
  ```
* Rebuild after changes: `docker build -t my-node-app .` (use a new tag or same tag — same tag will overwrite the tag reference).
* To test different host ports, change the left side of `-p`: `-p 8080:80` maps `localhost:8080` → container `80`.
