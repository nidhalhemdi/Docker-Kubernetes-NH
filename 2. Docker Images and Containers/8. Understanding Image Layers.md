# **Understanding Image Layers**

## **1. Images Are Layer-Based**

Docker images are built as a **stack of layers**, where **each instruction in a Dockerfile produces one layer**.

Examples of layer-creating instructions:

* `FROM`
* `WORKDIR`
* `COPY`
* `RUN npm install`
* `EXPOSE`
* `CMD`

---

## **2. Docker Caching**

When you rebuild an image with `docker build .`, Docker checks each instruction:

### **If nothing changed in a step or earlier steps → Docker reuses the cached layer.**

This is why the build can finish in seconds.

### **If something DID change →**

* Docker re-runs **that** instruction
* AND **every instruction after it**
  (because later steps depend on earlier ones)

---

## **3. Example: Changing Source Code**

If you edit your `server.js` or any other file that’s copied by:

```dockerfile
COPY . .
```

Then:

* Docker detects the file change
* The **COPY** layer is rebuilt
* **All subsequent layers** (like `RUN npm install`) are rebuilt
  → even if npm install is *not* needed.

---

## **4. Container Layer**

When running an image:

* Docker adds a **final writable layer** on top of the read-only image layers.
* This is where runtime changes live (temporary).

---

## **5. Optimization Technique**

Goal: avoid re-running `npm install` every time you change source code.

### ❌ **Current approach**:

```dockerfile
COPY . .
RUN npm install
```

Any change to **any** source file invalidates the cache for both layers.

### ✔️ **Optimized approach**:

Copy `package.json` first, install dependencies, then copy the rest:

```dockerfile
COPY package.json .
RUN npm install
COPY . .
```

**Why this works:**
If only source files change but `package.json` does NOT:

* Cache for `npm install` remains valid
* Only final `COPY . .` layer rebuilds
  → **Much faster rebuilds**

---

## **6. Practical Demo from the Lecture**

* First build with the optimized Dockerfile → `npm install` runs normally.
* Later source code changes → instant rebuild (cache hit).
* The only re-executed layer is the `COPY . .` step.

---

## ✔️ **Core Takeaways**

* Docker images use a **layer-based architecture**.
* **Each Dockerfile instruction = one layer**.
* **Caching makes builds fast**.
* If a layer changes, **all following layers rebuild**.
* To optimize builds, place instructions that change rarely (like dependencies) **before** instructions that change frequently (like source code).

