# **Bind Mounts**

You now understand **volumes** (for persistent data).
Bind mounts are similar â€” but they solve a **different problem**:
â¡ï¸ **Live code updates during development**.

---

# ğŸš¨ **The Problem**

When you run a container:

* Docker **copies** your source code into the image once (snapshot).
* If you **change** a file on your machine, the running container **does NOT see the change**.
* You must **rebuild the image** for every change â†’ super annoying during development.

---

# ğŸ› ï¸ **The Solution: Bind Mounts**

A **bind mount** connects:

* a folder **on your host machine**, to
* a folder **inside the container**.

But hereâ€™s the big advantage:

### âœ”ï¸ Changes on your machine instantly appear inside the container

### âœ”ï¸ Changes inside the container appear on your machine

### âŒ Not managed by Docker â€” **you choose the exact path**

That makes bind mounts perfect for **editable source code** during development.

---

# ğŸ“Œ **Important Difference From â€œnamed volumesâ€**

| Feature                                    | Named Volume | Bind Mount |
| ------------------------------------------ | ------------ | ---------- |
| Located & managed by Docker                | âœ”ï¸           | âŒ          |
| You know the exact folder location on host | âŒ            | âœ”ï¸         |
| Good for persistent data                   | âœ”ï¸           | âœ”ï¸         |
| Good for editing source code               | âŒ            | âœ”ï¸ BEST    |

Bind mounts = â€œshare this host folder exactly with the container.â€

---

# ğŸ§ª **How You Add a Bind Mount**

You run:

```
docker run -v "ABSOLUTE_PATH_TO_PROJECT:/app" ...
```

**Left side:** folder on your machine
**Right side:** folder inside the container

Since your project source code is in `/app` *inside the container*, you map the project folder to that location.

---

# ğŸ’¥ **Why the Container Crashes After Adding Bind Mount**

After adding the bind mount, Docker now does this:

### 1. You map your local project folder â†’ `/app`

### 2. But `/app` inside container originally contained:

* your JS files
* **node_modules (installed during image build)**

When you bind-mount your folder, you **overwrite** the containerâ€™s `/app` folder entirely.

And your local folder **does NOT contain `node_modules`** (because you didnâ€™t run `npm install` on your machine).

So inside the container:

â¡ï¸ `/app/node_modules` = **gone**
â¡ï¸ Node tries to start â†’ **cannot find Express â†’ container exits**.

This is **expected**.

---

# ğŸ§© **This is the root cause:**

### **Bind mount replaces the entire `/app` folder, removing node_modules created during build.**

---

# ğŸ”œ **In the next lecture**

He will solve this by:

* Using a named volume for `node_modules`
* Using a bind mount only for application source code

This way:

* node_modules â†’ stays inside container (not overwritten)
* src code â†’ comes from your machine (live updates possible)

