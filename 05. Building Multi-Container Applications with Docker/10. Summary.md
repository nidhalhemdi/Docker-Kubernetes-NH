# âœ… **Module Summary (Concise Notes)**

### **Topic: Multi-Container Applications in Docker (Development Setup)**

## **1. What You Built**

A complete multi-service application with **three standalone containers**:

1. **MongoDB database**
2. **Backend API (Node.js / Go)**
3. **Frontend React SPA**

Each service runs in **its own isolated container**, but all containers:

* Can talk to each other (Docker networking)
* Can persist data when needed (volumes)
* Support live code updates (bind mounts & reloading)

---

## **2. Core Lessons Learned**

### âœ” **How to split an app into multiple services**

Each service:

* Has its **own Dockerfile**
* Runs as **its own container**
* Communicates through a **Docker network**

  * Often using container names instead of localhost

Example:

```
MONGO_DB_HOST=mongodb
```

(instead of `localhost`)

---

### âœ” **Using Volumes**

You used volumes for:

* DB persistence
* Avoiding node_modules conflicts
* Enabling live-reload on frontend/backend

Examples:

```
-v data:/data/db
-v logs:/app/logs
-v .:/app
```

---

### âœ” **Live Code Reloading**

During development:

* React auto-reloads
* Backend auto-reloads (nodemon, etc.)
* Achieved by **bind mounts**, not copying code into the image

---

### âœ” **Typical Problems Faced**

1. **React could not talk to Node backend**

   * Fix: correct container hostnames + ports + CORS

2. **Environment variables**

   * Must be passed to Docker with `-e KEY=value`

3. **Multiple long Docker run commands**

   * Easy to forget a volume or env variable â†’ app breaks

---

## **3. Why This Module Matters**

* You now understand how to combine multiple containers to form one application.
* You practiced:

  * Volumes
  * Networking
  * Bind mounts
  * Environment variables
  * Container isolation
* This is how real apps are structured (DB + backend + frontend).

---

## **4. Important Note: This Was *Development Setup***

The configuration here is **NOT production-ready**.

Why?

* Uses auto-reload processes
* Uses bind mounts
* Uses long `docker run` commands
* Not optimized images

Production requires:

* Different Dockerfiles
* No live reload
* Different build steps
* Proper networking & environment configuration
* Deployment tooling

This will be covered later.

---

## **5. Major Pain Point: Too Many `docker run` Commands**

You currently have 3 long commands:

### Example:

```
docker run -v data:/data/db --network goals-net --name mongodb mongo
docker run -v logs:/logs -e MONGO_URL=mongodb://mongodb:27017 ...
docker run -v .:/app -p 3000:3000 ...
```

Problems:

* Easy to forget a volume or env variable
* Must run containers **one by one**
* Tiresome when containers are recreated

---

## **6. What Comes Next**

The next module will fix this by introducing a tool that can:

* Run **multiple containers with one command**
* Define volumes, networks, env vars, ports in one file
* Remove the need to memorize long commands

ðŸ‘‰ This is **Docker Compose**.

---

# ðŸ“Œ **Key Takeaways (Short & Practical)**

* Multi-container apps = multiple services in separate containers.
* Use **networks** so containers talk using names.
* Use **volumes** for persistence and development convenience.
* Use **bind mounts** + auto-reload tools during development.
* Donâ€™t deploy this setup to production.
* Current workflow is inefficient â†’ **Docker Compose** solves it.
