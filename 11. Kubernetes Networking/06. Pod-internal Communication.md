# **Pod-Internal Communication**

---

# ğŸš€ **Core Concept**

When **two containers run inside the same Pod**, they share:

* the same **network namespace**
* the same **localhost interface**

ğŸ‘‰ **This means containers in the same Pod can talk to each other using `localhost:<port>`**

This works **only inside the same Pod** â€” not across different Pods.

---

# ğŸ§  **How Pod-Internal Communication Works**

* Each container exposes its own ports inside the shared Pod network.

* If container A needs to reach container B (same Pod):

  **Use:**

  ```
  localhost:<port-of-container-B>
  ```

* Kubernetes does **not** assign container-to-container DNS names inside a Pod.

* `localhost` is the guaranteed internal hostname.

---

# ğŸ› ï¸ **Applying This to Users-API & Auth-API**

### **Step 1 â€” Update the Deployment**

Inside `users-deployment.yaml`, in the **users-api container**, add:

```yaml
env:
  - name: AUTH_ADDRESS
    value: "localhost:80"
```

Why `80`?
â†’ The **auth-api** listens on port **80**.

This sets `process.env.AUTH_ADDRESS` to the correct Pod-internal address.

---

# ğŸ§ª **Testing the Deployment**

### After adding the environment variable:

1. **Apply the updated Deployment**

```bash
kubectl apply -f users-deployment.yaml
```

2. Kubernetes replaces the old Pod:

   * Old Pod â†’ terminating
   * New Pod â†’ created
   * New Pod has **2/2 containers running**

3. Check Pods:

```bash
kubectl get pods
```

Output example:

```
NAME                 READY   STATUS    ...
users-deployment-â€¦   2/2     Running
```

âœ” **`2/2` means both containers started successfully.**

---

# ğŸ§ª **HTTP Test (via Minikube service URL)**

Send POST request to:

```
http://<minikube-ip>:<service-port>/signup
```

with JSON body:

```json
{
  "email": "test@example.com",
  "password": "123456"
}
```

**Expected result:**
`User created` â†’ proving users-api successfully contacted auth-api using `localhost`.

Then test:

```
/login
```

**Expected result:**

```
token: "abc"
```

This confirms:

* users-api forwarded the login request to auth-api
* auth-api returned the token
* pod-internal communication using `localhost` works

---

# ğŸ“ **What You Should Remember**

* Pods share a network interface â†’ containers communicate via **localhost**.
* Everything inside one Pod = **shared network**.
* Environment variable configuration is required:

  * Docker Compose â†’ `AUTH_ADDRESS=auth`
  * Kubernetes â†’ `AUTH_ADDRESS=localhost:80`
* Deployments update Pods automatically on `kubectl apply`.
