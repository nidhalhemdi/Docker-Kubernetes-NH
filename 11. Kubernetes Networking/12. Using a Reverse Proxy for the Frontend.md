# **Using a Reverse Proxy for the Frontend**

## ğŸ¯ **Problem**

The frontend needs to call the backend (`tasks-service`) via an API URL.

Originally, the React code contained a **hard-coded URL**, such as:

```js
fetch("http://<external-ip>:8000/tasks");
```

This is **not ideal** because:

* URLs of services may change.
* Hardcoding backend IPs makes the frontend less flexible.
* The backend IP used from *outside* the cluster is not accessible *inside* the container.

---

# ğŸ’¡ **Solution: Use NGINX as a Reverse Proxy Inside the Frontend Container**

Instead of sending API requests directly to the backend service URL, the browser sends the request to **the same server that serves the React frontend** â€” the NGINX server.

### What is a Reverse Proxy?

A **reverse proxy** forwards incoming requests to another backend server.

Here, we configure NGINX to:

* Serve the React app normally
* Forward requests that begin with `/api/` to the correct backend service inside the Kubernetes cluster

---

# ğŸ—ï¸ **1. Modify nginx.conf**

Inside the frontend image, in `nginx.conf`, add:

```nginx
location /api/ {
    proxy_pass http://tasks-service.default.svc.cluster.local:8000/;
}
```

Key points:

* `/api/` acts as a prefix used only inside the cluster
* `proxy_pass` forwards requests to the Kubernetes internal service
* `tasks-service.default.svc.cluster.local` is automatically created by Kubernetes DNS
* Must include:

  * **Trailing slash after `/api/`**
  * **Trailing slash in proxy_pass**
  * **Correct backend port (8000)**

---

# ğŸ§© **2. Update React Code**

Replace the hardcoded backend URL:

âŒ Before:

```js
fetch("http://<external-ip>:8000/tasks");
```

âœ… After:

```js
fetch("/api/tasks");
```

Now the browser:

* Sends requests to the same origin as the frontend
* NGINX intercepts `/api/...` and forwards internally to the backend service

---

# âš™ï¸ **3. Rebuild and Redeploy Frontend**

Because the frontend image changed:

1. Rebuild the Docker image:

   ```bash
   docker build -t <user>/kub-demo-frontend .
   ```

2. Push it:

   ```bash
   docker push <user>/kub-demo-frontend
   ```

3. Delete the old deployment:

   ```bash
   kubectl delete -f frontend-deployment.yaml
   ```

4. Reapply:

   ```bash
   kubectl apply -f frontend-deployment.yaml
   ```

The service (`frontend-service`) stays the same, so the public URL doesnâ€™t change.

---

# ğŸ” **4. Why the First Attempt Failed**

Initially, the reverse proxy targeted the *external IP* of the tasks service.

But:

* NGINX configuration runs **inside the cluster**
* External IPs are only accessible **from outside**, not inside

Therefore, NGINX must use **internal cluster DNS names**, such as:

```
tasks-service.default
```

This resolves correctly inside Kubernetes.

---

# ğŸ‰ **5. Result**

After correcting the reverse proxy config and rebuilding:

* The frontend works again
* Tasks load correctly
* New tasks can be added
* No hardcoded backend IPs remain in the frontend source code ğŸ‰

---

# ğŸ’ **Benefits of This Pattern**

âœ” Avoids hard-coded backend addresses
âœ” Leverages Kubernetes DNS automatically
âœ” Makes frontend code portable and environment-agnostic
âœ” Works both for Kubernetes **and** on regular servers (like AWS)
âœ” Cleaner separation between frontend logic and deployment details

This pattern is widely used and considered best practice.
