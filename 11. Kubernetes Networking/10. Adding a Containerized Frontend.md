# **Adding a Containerized Frontend**

---

# üöÄ **Goal**

Introduce a **React frontend**, containerize it, test it locally, fix CORS/auth issues, and prepare it for **Kubernetes deployment** in the next lecture.

Up to now, all testing was done with **Postman**.
Now we‚Äôll test the real backend using an actual frontend UI.

---

# üß© **Key Concepts (Simple Definitions)**

### **Frontend Container**

A Docker image that:

* builds the React app
* serves the compiled files via **Nginx**

### **Browser-Executed Code**

React code **runs in the browser**, not inside the container.
‚Üí It can reach the backend using the same IP used in Postman (minikube's exposed IP).

### **CORS (Cross-Origin Resource Sharing)**

Browsers block requests to another domain/IP unless headers allow it.
Postman doesn‚Äôt enforce this ‚Üí works there, fails in browser.

### **Authorization Header**

Your backend requires:

```
Authorization: Bearer abc
```

The frontend must include this header in fetch requests.

---

# üõ†Ô∏è **Step-by-Step Practical Guide**

---

# 1Ô∏è‚É£ **Add the Frontend Folder**

A pre-built React project is provided.
Key file:

```
frontend/src/App.js
```

Contains:

* fetching tasks
* posting new tasks
* but missing the backend URL

---

# 2Ô∏è‚É£ **Insert Backend URL**

Use the same URL you used with Postman:

Example:

```js
fetch('http://<minikube-ip>:<port>/tasks')
```

> You must insert your own minikube IP and NodePort.

---

# 3Ô∏è‚É£ **Build the Frontend Image**

Inside `frontend/`:

```
docker build -t nidhalhaamdii/kub-demo-frontend .
```

Dockerfile uses:

* multistage build
* builds React app
* copies build output into Nginx

---

# 4Ô∏è‚É£ **Run the Frontend Locally (not Kubernetes yet!)**

```
docker run -p 80:80 --rm -d nidhalhaamdii/kub-demo-frontend
```

Then open:

```
http://localhost
```

---

# 5Ô∏è‚É£ **Fix CORS Error**

Because backend lacks CORS headers.

Solution:
Replace your `tasks-app.js` with the provided updated version.

Important added code:

```js
res.setHeader("Access-Control-Allow-Origin", "*");
res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
```

This allows browser apps to call the backend.

---

# 6Ô∏è‚É£ **Rebuild and Redeploy the Tasks API**

After modifying backend code:

### Rebuild:

```
docker build -t nidhalhaamdii/kub-demo-tasks .
```

### Push:

```
docker push nidhalhaamdii/kub-demo-tasks
```

### Redeploy in Kubernetes:

Because YAML didn‚Äôt change, you must delete the deployment:

```
kubectl delete -f tasks-deployment.yaml
kubectl apply -f tasks-deployment.yaml
```

This forces Kubernetes to pull the updated image.

Backend pod will restart.

---

# 7Ô∏è‚É£ **Fix Authorization Error in Frontend**

The backend requires:

```
Authorization: Bearer abc
```

Add it to fetch requests:

```js
fetch(URL, {
  headers: {
    'Authorization': 'Bearer abc'
  }
});
```

---

# 8Ô∏è‚É£ **Rebuild Frontend with Updated Code**

```
docker build -t nidhalhaamdii/kub-demo-frontend .
```

Stop old container:

```
docker stop <container-name>
```

Run again:

```
docker run -p 80:80 --rm -d nidhalhaamdii/kub-demo-frontend
```

Now:

* fetching tasks works
* adding new task works

---

# üéØ **Why This Lecture Matters**

It prepares you to:

1. **Serve frontend to the browser**
2. **Make browser-based requests to Kubernetes services**
3. **Handle CORS + Authorization** (real-world must-have)
4. **Prepare the frontend image for Kubernetes deployment**

The next lecture will show how to host this frontend **inside the Kubernetes cluster**.
