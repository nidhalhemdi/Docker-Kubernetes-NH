# **Creating Multiple Deployments**

---

# ğŸš€ **What We Are Doing Now**

We are **refactoring the Kubernetes setup** so that each API (Users, Auth, Tasks) runs in **its own Pod** and is managed by **its own Deployment**.

Final target architecture:

* **Users API â†’ its own Pod + its own Service (public)**
* **Auth API â†’ its own Pod + its own Service (internal only)**
* **Tasks API â†’ its own Pod + its own Service (public)**

All services must be able to communicate **inside the cluster**, especially:

* **Users API â†’ Auth API**
* **Tasks API â†’ Auth API**

Auth API **must NOT be exposed externally**.

---

# ğŸ§© **Step-by-Step Changes**

## **1ï¸âƒ£ Split the Users & Auth containers**

Currently, Users API and Auth API run in the **same Pod**.
This must change: they must run in **different Pods**.

### Actions:

* Create a new file: `auth-deployment.yaml`
* Copy the structure of `users-deployment.yaml`

Then modify:

```yaml
metadata:
  name: auth-deployment

spec:
  selector:
    matchLabels:
      app: auth

template:
  metadata:
    labels:
      app: auth

  spec:
    containers:
      - name: auth
        image: <dockerhub-account>/kub-demo-auth:latest
```

Then modify **users-deployment.yaml**:

* remove the `auth` container entirely

Result:
âœ” Users API Pod
âœ” Auth API Pod

---

## **2ï¸âƒ£ Add a dedicated Service for Auth API**

A Deployment alone doesnâ€™t give a stable reachable address.

Pods get dynamic IPs â†’ *not reliable for communication*.

Therefore we MUST create:

### **auth-service.yaml**

Make it an **internal-only service**, not public.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: auth-service
spec:
  type: ClusterIP   # â—IMPORTANT â†’ internal only
  selector:
    app: auth
  ports:
    - port: 80       # Service port
      targetPort: 80 # Container port
```

âœ” This gives the Auth Pod a **stable DNS name** inside Kubernetes.

---

# ğŸŒ **3ï¸âƒ£ Problem: What AUTH_ADDRESS should be now?**

It **can no longer be**:

* `localhost` (Auth is now in a different Pod)
* `auth` (Docker Compose only)
* Pod IP address (changes all the time)

### **Correct answer: the Service name**

Inside Kubernetes, every service gets **automatic DNS**:

```
<service-name>.<namespace>.svc.cluster.local
```

But you only need the simple name:

```
auth-service
```

This resolves to the Auth Pod **inside the cluster**.

---

## âœ” Updated `AUTH_ADDRESS` for Users API and Tasks API

In **users-deployment.yaml**:

```yaml
env:
  - name: AUTH_ADDRESS
    value: "auth-service"
```

And later for **tasks-deployment.yaml**:

```yaml
env:
  - name: AUTH_ADDRESS
    value: "auth-service"
```

No port needed here because the Auth serviceâ€™s port **is already 80**, which Axios uses by default when a port isnâ€™t specified.

If you wanted to be explicit:

```
auth-service:80
```

Works too.

---

# ğŸ¯ **Final Result After This Lecture**

You will have:

### **Deployments**

* `users-deployment`
* `auth-deployment`
* (soon) `tasks-deployment`

### **Services**

* `users-service` (LoadBalancer â†’ public)
* `auth-service` (ClusterIP â†’ internal only)
* (soon) `tasks-service` (LoadBalancer â†’ public)

### **Communication**

* Users API â†’ Auth API: via `auth-service`
* Tasks API â†’ Auth API: via `auth-service`
* External clients â†’ Users API / Tasks API only
