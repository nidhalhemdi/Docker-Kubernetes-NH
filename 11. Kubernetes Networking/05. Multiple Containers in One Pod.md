# **Multiple Containers in One Pod**

---

## âœ… **Key Idea**

You are preparing the **users-api** to communicate with the **auth-api**, and BOTH will run **inside the same Pod**, meaning *Pod-internal communication*. You fix the code, rebuild images, push them, and update the Kubernetes Deployment to include **two containers in one Pod**.

---

# ğŸ§© **1. Fixing the Users API Code**

Previously you replaced axios calls with dummy text.
Now you **restore the real axios calls** but you must **replace the hard-coded `auth` service hostname** with an environment variable.

### **Why?**

* In Docker Compose, using `auth` works (Compose creates a network where service names are hostnames).
* In Kubernetes, that hostname will NOT work.
* Solution â†’ **Use an environment variable: `AUTH_ADDRESS`**.

### **Updated JavaScript Code Pattern**

Use **backticks** and **template strings**:

```js
`http://${process.env.AUTH_ADDRESS}/signup`
```

Apply this for **signup** and **login** routes.

---

# âš™ï¸ **2. Docker Compose (only for local flexibility)**

Inside `docker-compose.yaml` under the **users-service**:

```yaml
environment:
  - AUTH_ADDRESS=auth
```

(Different values will be used later in Kubernetes.)

---

# ğŸ—ï¸ **3. Build & Push the Auth API Image**

You must build and push the `auth-api` image so Kubernetes can pull it.

### **Commands**

```bash
cd auth-api
docker build -t <your-dockerhub-username>/kub-demo-auth:latest .
docker push <your-dockerhub-username>/kub-demo-auth:latest
```

Create the repository on Docker Hub if you haven't already.

---

# ğŸ«™ **4. Putting Both Containers in ONE Pod**

We **do NOT create a new Deployment**.
Why?

* A Deployment defines **one type of Pod**.
* We want **two containers inside the same Pod**, not separate Pods.

### Modify the existing `users-deployment.yaml`:

Add this under `spec.template.spec.containers`:

```yaml
- name: auth
  image: <your-dockerhub-username>/kub-demo-auth:latest
```

Also keep:

```yaml
- name: users
  image: <your-dockerhub-username>/kub-demo-users:latest
```

---

# ğŸš« **5. Do NOT Expose Auth API via the Service**

* **users-api** must be reachable from outside â†’ Expose its port.
* **auth-api** must *only* be reachable *inside the Pod* â†’ Do NOT expose it.

### Your Service YAML still exposes ONLY the users-api port:

```yaml
ports:
  - port: 8080
    targetPort: 8080 # users-api only
```

Auth-api listens on port 80, but we **donâ€™t** expose it.

---

# ğŸ” **6. Rebuild & Push the Updated Users API**

Because the code was changed to use the environment variable:

```bash
cd users-api
docker build -t <your-dockerhub-username>/kub-demo-users:latest .
docker push <your-dockerhub-username>/kub-demo-users:latest
```

---

# ğŸ§© **7. The Key Question**

> What should the `AUTH_ADDRESS` be in Kubernetes?

You will learn in the next lecture, but the answer is:

* Since both containers are inside the **same Pod**,
* They communicate over **localhost**,
* But with their **container-internal port**.

â¡ï¸ Final value will be:

```
AUTH_ADDRESS=localhost:80
```

(Explained in the next lecture.)

---

# ğŸ“ **What This Lecture Teaches**

âœ” How to add **multiple containers in one Pod**
âœ” How to prepare code for **environment-dependent networking**
âœ” Why Docker Compose naming doesnâ€™t work in Kubernetes
âœ” How to NOT expose internal containers via Services
âœ” How to rebuild/push images when code changes
