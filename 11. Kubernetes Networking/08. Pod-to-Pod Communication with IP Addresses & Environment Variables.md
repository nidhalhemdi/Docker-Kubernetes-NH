# **Pod-to-Pod Communication with IP Addresses & Environment Variables**

---

# ğŸ¯ **Goal**

Enable communication between two different Pods (Users API â†’ Auth API) **using the Auth Service**, and learn:

1. How to get the service's internal **Cluster IP address**
2. How to use **Kubernetes auto-generated environment variables** instead of manually copying IPs

---

# ğŸ”¹ **1. Services Provide Stable Internal IPs**

Unlike Pods, Kubernetes **Services** have stable IPs.

Steps shown in the lecture:

### **Apply the Auth Deployment & Service**

```bash
kubectl apply -f auth-deployment.yaml
kubectl apply -f auth-service.yaml
```

### **Check the service's IP**

```bash
kubectl get services
```

â†’ Youâ€™ll see something like:

```
auth-service   ClusterIP   10.108.14.32   ...
```

This IP is **only accessible inside the cluster**, and can be used as:

```
AUTH_ADDRESS = "10.108.14.32"
```

### **Using the IP manually**

In *users-deployment.yaml*:

```yaml
env:
  - name: AUTH_ADDRESS
    value: "10.108.14.32"
```

Apply the updated deployment:

```bash
kubectl apply -f users-deployment.yaml
```

âœ” Login and signup still work â†’ communication succeeded.

### âš ï¸ Problem:

Copy-pasting the service IP manually is annoying.

---

# ğŸ”¹ **2. Kubernetes Auto-Generates Environment Variables**

Kubernetes automatically injects environment variables for every service.

Pattern:

```
<SERVICE_NAME_IN_CAPS>_SERVICE_HOST
```

Rules:

* lowercase â†’ uppercase
* dashes â†’ underscores
* append `_SERVICE_HOST`

### ğŸ“Œ Example

Service name:

```
auth-service
```

Auto-generated env variable:

```
AUTH_SERVICE_SERVICE_HOST
```

Its value = **the serviceâ€™s ClusterIP**

---

# ğŸ”¹ **3. Using the Auto-Generated Variable in Code**

In Node.js (users-api):

```js
const authServiceAddress = process.env.AUTH_SERVICE_SERVICE_HOST;
```

Then in the login route:

```js
axios.post(`http://${authServiceAddress}/login`, ...)
```

The signup route can still use the manually set `AUTH_ADDRESS`
â†’ so you can test both approaches.

---

# ğŸ”¹ **4. Ensuring Docker Compose Still Works**

Docker Compose **does NOT** generate this env var automatically.

So in **docker-compose.yaml**, you would need to add manually:

```yaml
environment:
  - AUTH_SERVICE_SERVICE_HOST=auth
```

Otherwise code will break when running locally.

---

# ğŸ”¹ **5. Rebuild & Redeploy Users API**

Because code changed:

### Build & push:

```bash
cd users-api
docker build -t <dockerhub-user>/kub-demo-users:latest .
docker push <dockerhub-user>/kub-demo-users:latest
```

### Apply updated deployment:

```bash
kubectl delete deployment users-deployment
kubectl apply -f users-deployment.yaml
```

(Deletion ensures Kubernetes pulls latest image with tag `latest`.)

---

# âœ”ï¸ **6. Final Verification**

Send both:

* **POST /signup** â†’ uses manually set IP
* **POST /login** â†’ uses auto-generated env var

Both requests work â†’ proof:

âœ” Service IP is correct
âœ” Auto-generated env variable resolves to the service IP
âœ” Pod-to-Pod communication is functioning

---

# âœ… **Key Takeaways (Very Important)**

### **1. Use Services for stable internal IPs**

Pods = dynamic IPs
Services = stable cluster IPs

---

### **2. You *can* manually set the service IP**

But this is not practical.

---

### **3. Kubernetes auto-creates env vars for every service**

Format:

```
<SERVICE_NAME>_SERVICE_HOST
```

Use these instead of hard-coding IPs.

---

### **4. Docker Compose does NOT auto-generate these**

You must manually define them if needed.

---

### **5. Rebuild & redeploy whenever code changes**

Use `kubectl delete` to force re-pull if using the `latest` tag.
