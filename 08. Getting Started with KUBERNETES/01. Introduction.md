# What this module covers

* **Goal:** introduce Kubernetes as a way to deploy and manage containers at scale — beyond single-host Docker.
* **Why:** Kubernetes is a standard framework for *container orchestration* so you can run many containers across many machines, reliably and cloud-independently.
* **Scope:** this module covers theory and core concepts.

# Key definitions

* **Container orchestration:** automated coordination of container lifecycle, scaling, networking and failover across many machines.
* **Kubernetes (k8s):** an open-source system (framework + APIs + components) that implements container orchestration and standardizes how you run containerized apps.
* **Cluster:** a group of machines (physical or virtual) running Kubernetes components.
* **Node:** a single machine in the cluster (worker or control-plane).
* **Pod:** the smallest deployable unit in Kubernetes — one or more containers that share network and storage.
* **Deployment:** a declarative object that manages ReplicaSets and pods for stateless apps (handles rolling updates, scaling).
* **Service:** a stable network endpoint that exposes one or more pods (load balancing + discovery).
* **Control plane (core components):** API server, scheduler, controller-manager — they make decisions and manage cluster state.
* **kubelet:** agent on each node that ensures containers described by pods are running.
* **Namespace, Labels, Selectors:** organizational and selection tools for grouping and targeting objects.

# Problems Kubernetes helps solve

* Running many containers across many machines (scheduling & placement).
* Automatic restarts, health checks and self-healing.
* Rolling updates and rollbacks.
* Service discovery & load balancing between containers.
* Declarative infrastructure: desired-state management via manifests (YAML).

# Practical tips & study method

1. **Start local, then move to cloud**

   * Learn concepts locally with Minikube or kind (Kubernetes in Docker) so you can experiment without a cloud bill.
2. **Learn by doing**

   * Create a simple app, containerize it, deploy it as a Pod → Deployment → expose it with a Service. Observe behavior when you scale, crash pods, updates.
3. **Keep manifests small & declarative**

   * One object per YAML file during practice (easier to reason about). Use `kubectl apply -f` for idempotent changes.
4. **Use the `kubectl` triage flow**

   * `kubectl get` → `kubectl describe` → `kubectl logs` → `kubectl exec` to debug.
5. **Understand the control plane vs worker nodes**

   * Know which components run where (control plane makes decisions; kubelets enforce them on nodes).
6. **Learn common object types first**

   * Pods, Deployments, Services, ConfigMaps, Secrets, PersistentVolumes / PersistentVolumeClaims.
7. **Use labels & selectors**

   * Design labels early; they’re critical for service targeting, rolling upgrades and managing resources.
8. **Practice rolling updates & rollbacks**

   * Update an image tag in a Deployment and watch k8s do zero-downtime updates (and rollback if needed).

# Quick cheat-sheet — commands to get started locally

(choose one local option)

**Using Minikube**

```bash
# install minikube (OS-specific) then:
minikube start
kubectl version --client
kubectl get nodes
```

**Using kind (Kubernetes in Docker)**

```bash
# create a cluster with kind
kind create cluster --name my-cluster
kubectl cluster-info --context kind-my-cluster
kubectl get nodes
```

**Basic kubectl workflow**

```bash
# create a deployment
kubectl create deployment nginx --image=nginx

# see deployed objects
kubectl get deployments
kubectl get pods

# expose deployment as a service (NodePort or ClusterIP)
kubectl expose deployment nginx --port=80 --type=NodePort

# inspect service & endpoints
kubectl get svc
kubectl describe svc nginx

# scale
kubectl scale deployment nginx --replicas=3
kubectl get pods

# view logs / exec into pod
kubectl logs <pod-name>
kubectl exec -it <pod-name> -- /bin/sh

# apply a manifest (preferred)
kubectl apply -f my-deployment.yaml

# rolling update (change image in manifest then apply)
kubectl rollout status deployment/nginx
kubectl rollout undo deployment/nginx   # rollback
```

# Small YAML example (Deployment + Service)

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
spec:
  replicas: 2
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - name: web
        image: nginx:stable
        ports:
        - containerPort: 80
---
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: web-svc
spec:
  selector:
    app: web
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
```

Use `kubectl apply -f deployment.yaml` to create both objects.

# Notes about production

* Managed Kubernetes (EKS/GKE/AKS) removes much of control-plane overhead—good for production.
* For production you’ll need to learn networking (Ingress), storage classes, RBAC, monitoring (Prometheus), logging, and CI/CD integration.

