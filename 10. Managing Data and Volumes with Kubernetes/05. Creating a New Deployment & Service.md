# **Creating a New Deployment & Service**

This lecture shows how to prepare a Deployment and a Service for your “story” app **before** you add volumes.
It also explains the steps for building and pushing the Docker image and exposing your app through Minikube.

---

# 1️⃣ Create the **Deployment**

### **deployment.yaml** contains:

* `apiVersion: apps/v1`
* `kind: Deployment`
* `metadata` → name of the deployment
* `spec`:

  * `selector` (match labels)
  * `replicas`
  * `template` → defines the Pod

### Inside the **Pod template**:

#### ✅ **metadata → labels**

```yaml
metadata:
  labels:
    app: story
```

This label is important because:

* The Deployment uses it to match Pods.
* The Service uses it to find these Pods.

#### ✅ **spec → containers**

```yaml
containers:
  - name: story
    image: nidhalhaamdii/kub-data-demo
```

* `name` can be anything (he used "story")
* `image` must be your Docker Hub repository
* You **must** push this image to Docker Hub first, because Kubernetes pulls images from a registry (Minikube can't access your local Docker daemon unless configured).

---

# 2️⃣ Create the **Service**

### **service.yaml** contains:

* `apiVersion: v1`
* `kind: Service`
* `metadata` → name (he used *story-service*)
* `spec`:

  * `selector`: matches Pods with `app: story`
  * `ports` mapping
  * `type: LoadBalancer` ← important!

### Example:

```yaml
spec:
  selector:
    app: story
  type: LoadBalancer
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
```

**Explanation:**

* `port: 80` → the port exposed by the Service
* `targetPort: 3000` → the port inside the container (app listening port)
* `type: LoadBalancer` → required for Minikube to expose a URL
  (otherwise the Service is internal only)

---

# 3️⃣ Build & Push the Docker Image

Before deploying, you must push the image to Docker Hub:

```bash
docker build -t nidhalhaamdii/kub-data-demo .
docker push nidhalhaamdii/kub-data-demo
```

Minikube → pulls images from Docker Hub by default.
So this step is required.

---

# 4️⃣ Apply Deployment & Service

Make sure Minikube is running:

```bash
minikube start
minikube status
```

Then apply both files:

```bash
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
```

Check deployment status:

```bash
kubectl get deployments
```

---

# 5️⃣ Expose the app with Minikube

To get an external URL for the service:

```bash
minikube service story-service
```

If you **forgot to add `type: LoadBalancer`**, Kubernetes creates a **ClusterIP** service (internal-only), and Minikube cannot expose it.
→ This is why the lecturer had to reapply the service after adding the type.

After fixing and re-applying:

```bash
kubectl apply -f service.yaml
minikube service story-service
```

You get a URL like:

```
http://127.0.0.1:xxxxx
```

---

# 6️⃣ Test the API

In Postman:

* GET `…/story` → returns empty initially
* POST `…/story` → sends some text data
* GET again → now returns stored data

At this point everything works **but the data is not persisted**.
If the Pod restarts, the data is lost.

This is where volumes come in — which is what the next lecture covers.
