# **Whatâ€™s the main point of this lecture?**

This lecture explains **how to use environment variables inside Kubernetes Pods**, and **why you would want to do that**â€”especially to avoid hard-coding values inside your application code.

---

## ğŸ’¡ **Why environment variables?**

In the app, the folder used to store data (e.g., `"story"` folder) was **hard-coded** inside `app.js`.

But this is bad practice because:

* You canâ€™t easily change it later.
* Configuration shouldnâ€™t be inside code.
* Kubernetes allows you to pass configuration **from the YAML files**, not from inside the image.

So the instructor changes:

```js
const folder = "story";
```

to:

```js
const folder = process.env.STORY_FOLDER;
```

Now the folder is configurable from outside the app.

---

## ğŸ“¦ **How Kubernetes provides environment variables**

In the **Deployment YAML** (`deployment.yaml`), inside the container configuration, you add:

```yaml
env:
  - name: STORY_FOLDER
    value: "story"
```

This means:

* `STORY_FOLDER` will be available inside the container.
* Your app can read it with `process.env.STORY_FOLDER`.

This is the Kubernetes equivalent of Docker:

```yaml
environment:
  - STORY_FOLDER=story
```

---

## ğŸ§± **Where does it go in deployment.yaml?**

Under:

```yaml
spec:
  template:
    spec:
      containers:
        - name: ...
          image: ...
          volumeMounts:
          env:
            - name: STORY_FOLDER
              value: "story"
```

The `env` key is always defined **per container**, not per pod.

---

## ğŸ”„ **Rebuilding and redeploying the image**

Since app.js was modified, a new Docker image must be built:

```bash
docker build -t academind/kub-data-demo:2 .
docker push academind/kub-data-demo:2
```

Then update the deployment to use the new tag:

```yaml
image: academind/kub-data-demo:2
```

Or set pull policy to always pull.

Apply the update:

```bash
kubectl apply -f deployment.yaml
```

Kubernetes replaces the old Pods with new Pods.

---

## âœ”ï¸ **Result**

* App works exactly the same.
* But now the folder name is **not hard-coded**.
* Kubernetes controls configuration â†’ *cleaner, scalable setup*.
