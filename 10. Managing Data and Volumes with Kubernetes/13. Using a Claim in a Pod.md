# **Storage Classes + PV/PVC Binding Explained**

At this point, you already understand:

* **PV = the actual storage**
* **PVC = a request for storage**
* **Pod = uses the claim (PVC), not the PV directly**

But one essential concept was missing before applying the YAML:

# ‚≠ê **StorageClass (SC)**

A **StorageClass** tells Kubernetes *how* to provision storage.

It defines the ‚Äúpolicy" for creating volumes:

* What backend driver to use
* How volumes should be created
* Whether to dynamically provision PVs
* How reclaiming works
* The type of storage (hostPath, NFS, AWS EBS, etc.)

Minikube comes with a **default StorageClass** named `standard`.

That‚Äôs why when you run:

```
kubectl get sc
```

You see:

```
standard (default)
```

This storage class is already configured to work with Minikube‚Äôs local hostPath storage.

---

# üö® **Why You Must Add `storageClassName`**

Your PV and PVC **must agree on the StorageClass**, otherwise Kubernetes will NOT bind them.

You fix this by adding:

### In `host-pv.yaml`

```
storageClassName: standard
```

### In `host-pvc.yaml`

```
storageClassName: standard
```

This ensures the PV and PVC belong to the same ‚Äúgroup‚Äù of storage rules.

If they don‚Äôt match ‚Üí the PVC will remain **Pending**, and PV remains **Available**, not **Bound**.

---

# üîó **What Happens After Adding the StorageClass**

Once you apply:

```
kubectl apply -f host-pv.yaml
kubectl apply -f host-pvc.yaml
```

Now Kubernetes can bind them:

### Check PV:

```
kubectl get pv
```

You expect:

```
NAME       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   STORAGECLASS
host-pv    1Gi        RWO            Retain           Bound    standard
```

### Check PVC:

```
kubectl get pvc
```

You expect:

```
NAME       STATUS   VOLUME     STORAGECLASS
host-pvc   Bound    host-pv    standard
```

Now your pod can successfully use this claim.

---

# üß† **Why the StorageClass Matters (Even with hostPath)**

Even though you're using a simple local filesystem via:

```
hostPath: /data
```

The StorageClass still influences:

* How Kubernetes interprets the volume
* Whether binding is allowed
* How provisioning/reclaiming policies work
* Whether dynamic provisioning is used

In Minikube, the default `standard` class is designed to support hostPath volumes‚Äîso everything works.

In cloud environments (AWS/GCP/Azure), StorageClasses become **critical**, because they define:

* AWS EBS storage behavior
* Azure Disk types
* Google Persistent Disk types
* EFS/NFS CSI drivers
* Dynamic provisioning rules

---

# üéâ **Final Result**

After applying the PV, PVC, and updated Deployment:

* The pods restart and continue using the same data
* The PVC gives you pod independence
* Using a PV frees you from container lifecycle
* Using a proper storage backend (not hostPath) gives you **node independence**

HostPath still binds you to a single node ‚Äî but the **concept** is the same regardless of backend.
