# **What the Lecture Is Teaching**

You already learned how to set environment variables **directly in the Deployment YAML**.
Now we show how to put those values **into a separate Kubernetes resource called a ConfigMap**, which allows:

* Cleaner configuration
* Reusable values across multiple pods
* No hard-coding of environment variables in Deployment YAML
* Centralized management of settings

This is the **Kubernetes best practice** for non-secret configuration values.

---

# ğŸ§© **What is a ConfigMap?**

A **ConfigMap** is a Kubernetes object that stores **keyâ€“value pairs**.

It is used for:

* Environment variables
* App configuration
* File-like config
* Centralized settings

Itâ€™s similar to `.env` files in Docker, but stored inside the cluster.

---

# ğŸ“„ **1. Creating a ConfigMap (environment.yaml)**

You create a new YAML file:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: data-store-env
data:
  folder: "story"
```

* `folder` = key
* `"story"` = value

You can put **many keys** here if you want.

Apply it:

```bash
kubectl apply -f environment.yaml
```

Check it:

```bash
kubectl get configmap
```

---

# âš™ï¸ **2. Using a ConfigMap in a Deployment**

Instead of:

```yaml
env:
  - name: STORY_FOLDER
    value: "story"
```

You use:

```yaml
env:
  - name: STORY_FOLDER
    valueFrom:
      configMapKeyRef:
        name: data-store-env
        key: folder
```

Meaning:

* Read from the ConfigMap called `data-store-env`
* Take the value of its key `folder`
* Use it as the value of the environment variable `STORY_FOLDER` inside the container

Your application code still uses:

```js
process.env.STORY_FOLDER
```

---

# ğŸ”„ **Deployment update**

After updating `deployment.yaml`, apply it:

```bash
kubectl apply -f deployment.yaml
```

Kubernetes will:

* Terminate old pods
* Start new pods using the ConfigMap value

App behavior stays the same â€” only config handling changed.

---

# ğŸ’¡ **Why Use ConfigMaps?**

### âœ” Centralizes configuration

Only modify the ConfigMap â†’ all pods using it receive the updated values.

### âœ” Makes environment variables reusable

Multiple deployments can reference the same ConfigMap.

### âœ” Keeps Deployment files clean

Your Deployment YAML stays focused on workload definition.

### âœ” Avoids hard-coding values

Better maintainability, cleaner codebase.

---

# ğŸš« **One important rule**

You must choose **either**:

### Set direct value:

```yaml
value: "something"
```

OR

### Load from ConfigMap:

```yaml
valueFrom:
  configMapKeyRef:
```

You **cannot use both together**.

---

# ğŸ‰ **Summary**

* A **ConfigMap** allows storing environment variables in a separate Kubernetes resource.
* You reference it from the Deployment using `valueFrom.configMapKeyRef`.
* It improves maintainability, reusability, and separation of concerns.
* Application code does NOT change â€” only how Kubernetes provides the value changes.
