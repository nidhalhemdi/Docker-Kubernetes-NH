# â€œA First Volume: The *emptyDir* Typeâ€

This lecture introduces your **first Kubernetes volume**, and explains how to configure it using the `emptyDir` type.

---

# ğŸ¯ **Why we need a volume**

Before creating the volume, the instructor forces the container to **crash** using a new `/error` route:

```js
app.get('/error', (req, res) => {
  process.exit(1);
});
```

* When the container crashes, **Kubernetes automatically restarts it**.
* But because **no volume is used**, the containerâ€™s internal filesystem resets â†’ **stored data disappears**.

This demonstrates the need for a volume.

---

# ğŸ§  **Important Kubernetes concept**

Volumes in Kubernetes are:

* **Attached to Pods**, not containers
* **Shared by all containers** inside the same Pod
* **Alive as long as the Pod is alive**
* **NOT persistent across Pod recreation/replacement**

Because a volume belongs to the Pod definition, we must configure it in the **pod template inside the Deployment YAML**.

---

# ğŸ›  Step 1 â€” Define the Volume in the Pod Spec

Inside `deployment.yaml`, under **spec.template.spec** (same level as `containers:`):

```yaml
volumes:
  - name: story-volume
    emptyDir: {}
```

### What `emptyDir` does:

* Creates a **new empty directory** when the Pod starts
* Exists as long as the **Pod exists**
* Survives **container restart**
* Is deleted when the **Pod is deleted**
* No configuration is needed â†’ `{}` is enough

This solves the â€œcrash and lose dataâ€ problem.

---

# ğŸ›  Step 2 â€” Mount the Volume inside the Container

Inside the container definition:

```yaml
volumeMounts:
  - name: story-volume
    mountPath: /app/story
```

### Why this path?

In the Node.js application:

* Stories are stored in `/app/story/text.txt`
* `/app` is the working directory set in the Dockerfile
* The volume must be mounted **exactly where the app writes data**

---

# ğŸ§ª What happens now?

### 1ï¸âƒ£ Apply the updated Deployment

Kubernetes replaces the old Pod with a new one.

â†’ Your `/story/text.txt` file is lost once (because it's a new Pod).

### 2ï¸âƒ£ App behavior

When you send POST requests, data is stored in:

```
/app/story/text.txt
```

â€”which now lives **inside the emptyDir volume**.

### 3ï¸âƒ£ Trigger the crash using `/error`

The container restarts.

### 4ï¸âƒ£ Send `GET /` again

ğŸ‰ **Data is still there!**

Because:

* The Pod stayed the same
* Only the container restarted
* The volume remained intact

---

# ğŸ“Œ Why â€œemptyDirâ€ is NOT enough long-term

`emptyDir` solves:

âœ”ï¸ Data loss on container restart
âœ–ï¸ Data loss on Pod restart or replacement

If the Pod is recreated (deployment update, rescheduling, node shutdown), the entire directory is wiped.

This is why the next lectures introduce:

* **hostPath** (node-local persistence)
* **PersistentVolume + PersistentVolumeClaim** (cluster-level persistence)
